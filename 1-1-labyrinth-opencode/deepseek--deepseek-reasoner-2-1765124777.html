<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth Game</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: sans-serif;
            background: #000;
            color: #fff;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            max-width: 400px;
        }
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <h2>Labyrinth Game</h2>
            <button id="start-button">Start Game</button>
            <p id="status">Click Start to play</p>
        </div>
        <div id="instructions">
            <p><strong>Controls:</strong> W/A/S/D to move, mouse to look around.</p>
            <p>Click the Start button to lock pointer and begin.</p>
        </div>
        <canvas id="canvas-container"></canvas>
    </div>

    <script>
        // Map definition
        const map = [
            'XXXXXXXXXX',
            'Xs.....XXX',
            'XXXXXX.XXX',
            'XXXXXX.XXX',
            'XXX......X',
            'X.X......X',
            'X.X......X',
            'X.XX.XXX.X',
            'X........X',
            'XXXXXXXXXX'
        ];
        const wallPositions = new Set();
        const CELL_SIZE = 1; // meters
        const WALL_HEIGHT = 1;
        const PLAYER_HEIGHT = 1.7;

        // Scene setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 10, 50);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = PLAYER_HEIGHT;

        // Renderer
        const canvas = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -30;
        directionalLight.shadow.camera.right = 30;
        directionalLight.shadow.camera.top = 30;
        directionalLight.shadow.camera.bottom = -30;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Materials
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 });
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.9 });
        const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });

        // Variables
        let playerPosition = new THREE.Vector3();
        let playerDirection = new THREE.Vector3(0, 0, -1);
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isPointerLocked = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const moveSpeed = 5.0;

        // Initialize game
        init();
        animate();

        function init() {
            createMaze();
            setupEventListeners();
            updatePlayerStart();
        }

        function createMaze() {
            // Floor and ceiling
            const floorGeometry = new THREE.PlaneGeometry(CELL_SIZE * 10, CELL_SIZE * 10);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(5, 0, 5);
            floor.receiveShadow = true;
            scene.add(floor);

            const ceilingGeometry = new THREE.PlaneGeometry(CELL_SIZE * 10, CELL_SIZE * 10);
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(5, WALL_HEIGHT, 5);
            ceiling.receiveShadow = true;
            scene.add(ceiling);

            // Walls
            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            for (let z = 0; z < map.length; z++) {
                const row = map[z];
                for (let x = 0; x < row.length; x++) {
                    const cell = row[x];
                    if (cell === 'X') {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(x + 0.5, WALL_HEIGHT / 2, z + 0.5);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene.add(wall);
                        wallPositions.add(`${x},${z}`);
                    } else if (cell === 's') {
                        playerPosition.set(x + 0.5, 0, z + 0.5);
                    }
                }
            }
        }

        function updatePlayerStart() {
            camera.position.x = playerPosition.x;
            camera.position.z = playerPosition.z;
        }

        function isWallAt(x, z) {
            const gridX = Math.floor(x);
            const gridZ = Math.floor(z);
            return wallPositions.has(`${gridX},${gridZ}`);
        }

        function setupEventListeners() {
            // Pointer lock
            const startButton = document.getElementById('start-button');
            const statusText = document.getElementById('status');
            canvas.addEventListener('click', () => {
                if (!isPointerLocked) {
                    canvas.requestPointerLock();
                }
            });
            startButton.addEventListener('click', () => {
                canvas.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === canvas;
                statusText.textContent = isPointerLocked ? 'Pointer locked. Use WASD + mouse.' : 'Click canvas to lock pointer.';
                startButton.style.display = isPointerLocked ? 'none' : 'block';
            });

            // Keyboard
            document.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });

            // Mouse look
            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked) return;
                const sensitivity = 0.002;
                camera.rotation.y -= e.movementX * sensitivity;
                camera.rotation.x += e.movementY * sensitivity;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlayerMovement();
            renderer.render(scene, camera);
        }

        function updatePlayerMovement() {
            if (!isPointerLocked) return;
            const delta = 0.016; // approximate 60fps
            velocity.x = velocity.z = 0;
            if (moveForward) velocity.z -= moveSpeed * delta;
            if (moveBackward) velocity.z += moveSpeed * delta;
            if (moveLeft) velocity.x -= moveSpeed * delta;
            if (moveRight) velocity.x += moveSpeed * delta;

            // Move in camera direction
            direction.set(velocity.x, 0, velocity.z);
            direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
            
            const newX = camera.position.x + direction.x;
            const newZ = camera.position.z + direction.z;
            
            // Keep within map bounds (0 to 10)
            if (newX >= 0 && newX < 10 && newZ >= 0 && newZ < 10) {
                // Check wall collision at the new position
                if (!isWallAt(newX, newZ)) {
                    camera.position.x = newX;
                    camera.position.z = newZ;
                }
            }
            
            // Keep camera at player height
            camera.position.y = PLAYER_HEIGHT;
        }
    </script>
</body>
</html>