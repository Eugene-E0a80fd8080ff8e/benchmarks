<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.5);
        }

        #crosshair::before {
            width: 2px;
            height: 4px;
            left: 50%;
            top: -8px;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 2px;
            height: 4px;
            left: 50%;
            bottom: -8px;
            transform: translateX(-50%);
        }
    </style>
</head>
<body>
    <div id="info">
        <div>WASD - Move | Mouse - Look Around</div>
        <div>Position: <span id="pos">0, 0, 0</span></div>
    </div>
    <div id="crosshair"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowShadowMap;
        document.body.appendChild(renderer.domElement);

        // Labyrinth map
        const map = [
            "XXXXXXXXXX",
            "Xs.....XXX",
            "XXXXXX.XXX",
            "XXXXXX.XXX",
            "XXX......X",
            "X.X......X",
            "X.X......X",
            "X.XX.XXX.X",
            "X........X",
            "XXXXXXXXXX"
        ];

        const BLOCK_SIZE = 1;
        const PLAYER_HEIGHT = 1.7;
        let startPos = { x: 0, z: 0 };

        // Create labyrinth
        function createLabyrinth() {
            // Create walls
            for (let z = 0; z < map.length; z++) {
                for (let x = 0; x < map[z].length; x++) {
                    const cell = map[z][x];
                    if (cell === 'X') {
                        // Create wall cube
                        const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                        const material = new THREE.MeshStandardMaterial({
                            color: 0x8B8B8B,
                            roughness: 0.7,
                            metalness: 0.1
                        });
                        const cube = new THREE.Mesh(geometry, material);
                        cube.position.set(x * BLOCK_SIZE + BLOCK_SIZE / 2, BLOCK_SIZE / 2, z * BLOCK_SIZE + BLOCK_SIZE / 2);
                        cube.castShadow = true;
                        cube.receiveShadow = true;
                        scene.add(cube);
                    } else if (cell === 's') {
                        startPos = { x: x * BLOCK_SIZE + BLOCK_SIZE / 2, z: z * BLOCK_SIZE + BLOCK_SIZE / 2 };
                    }
                }
            }

            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(map[0].length * BLOCK_SIZE, map.length * BLOCK_SIZE);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x2d5016,
                roughness: 0.8,
                metalness: 0
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(map[0].length * BLOCK_SIZE / 2, 0, map.length * BLOCK_SIZE / 2);
            floor.receiveShadow = true;
            scene.add(floor);

            // Create ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(map[0].length * BLOCK_SIZE, map.length * BLOCK_SIZE);
            const ceilingMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.9,
                metalness: 0
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.set(map[0].length * BLOCK_SIZE / 2, 3, map.length * BLOCK_SIZE / 2);
            ceiling.receiveShadow = true;
            scene.add(ceiling);
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        scene.add(directionalLight);

        // Player controls
        const player = {
            position: new THREE.Vector3(startPos.x, PLAYER_HEIGHT, startPos.z),
            velocity: new THREE.Vector3(0, 0, 0),
            direction: new THREE.Vector3(0, 0, -1),
            pitch: 0,
            yaw: 0,
            speed: 0.15,
            friction: 0.85
        };

        const keys = {};
        const mouseMovement = { x: 0, y: 0 };

        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        document.addEventListener('mousemove', (e) => {
            mouseMovement.x = e.movementX;
            mouseMovement.y = e.movementY;
        });

        // Lock pointer on click
        document.addEventListener('click', () => {
            if (document.pointerLockElement === null) {
                document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
                document.body.requestPointerLock();
            }
        });

        // Collision detection
        function checkCollision(x, z) {
            const minX = 0.3;
            const maxX = map[0].length * BLOCK_SIZE - 0.3;
            const minZ = 0.3;
            const maxZ = map.length * BLOCK_SIZE - 0.3;

            if (x < minX || x > maxX || z < minZ || z > maxZ) {
                return true;
            }

            for (let checkZ = 0; checkZ < map.length; checkZ++) {
                for (let checkX = 0; checkX < map[checkZ].length; checkX++) {
                    if (map[checkZ][checkX] === 'X') {
                        const wallX = checkX * BLOCK_SIZE + BLOCK_SIZE / 2;
                        const wallZ = checkZ * BLOCK_SIZE + BLOCK_SIZE / 2;
                        const dist = Math.sqrt((x - wallX) ** 2 + (z - wallZ) ** 2);
                        if (dist < 0.6) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        // Game loop
        function animate() {
            requestAnimationFrame(animate);

            // Handle player movement
            const moveDirection = new THREE.Vector3(0, 0, 0);
            const moveSpeed = player.speed;

            if (keys['w']) {
                moveDirection.z -= moveSpeed;
            }
            if (keys['s']) {
                moveDirection.z += moveSpeed;
            }
            if (keys['a']) {
                moveDirection.x -= moveSpeed;
            }
            if (keys['d']) {
                moveDirection.x += moveSpeed;
            }

            // Rotate movement direction based on yaw
            const cos = Math.cos(player.yaw);
            const sin = Math.sin(player.yaw);
            const rotatedX = moveDirection.x * cos - moveDirection.z * sin;
            const rotatedZ = moveDirection.x * sin + moveDirection.z * cos;

            // Check collision before moving
            const newX = player.position.x + rotatedX;
            const newZ = player.position.z + rotatedZ;

            if (!checkCollision(newX, newZ)) {
                player.position.x = newX;
                player.position.z = newZ;
            }

            // Handle mouse look
            const sensitivity = 0.003;
            player.yaw -= mouseMovement.x * sensitivity;
            player.pitch -= mouseMovement.y * sensitivity;

            // Clamp pitch
            if (player.pitch > Math.PI / 2) player.pitch = Math.PI / 2;
            if (player.pitch < -Math.PI / 2) player.pitch = -Math.PI / 2;

            mouseMovement.x = 0;
            mouseMovement.y = 0;

            // Update camera
            camera.position.copy(player.position);
            
            // Create look direction based on pitch and yaw
            camera.rotation.order = 'YXZ';
            camera.rotation.y = player.yaw;
            camera.rotation.x = player.pitch;

            // Update info display
            document.getElementById('pos').textContent = 
                `${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}`;

            renderer.render(scene, camera);
        }

        // Create the labyrinth and start the game
        createLabyrinth();
        camera.position.copy(player.position);
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
