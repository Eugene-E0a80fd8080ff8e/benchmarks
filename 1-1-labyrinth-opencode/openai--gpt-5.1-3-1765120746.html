<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Labyrinth Cube Blocks</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            color: #f0f0f0;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
        }
        #overlay {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            background: radial-gradient(circle at center, rgba(0,0,0,0.85), rgba(0,0,0,0.98));
            text-align: center;
            z-index: 10;
        }
        #overlay h1 {
            margin: 0 0 0.5rem;
            font-size: 1.8rem;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }
        #overlay p {
            margin: 0.2rem 0;
            font-size: 0.95rem;
            color: #cccccc;
        }
        #overlay button {
            margin-top: 1.5rem;
            padding: 0.6rem 1.4rem;
            border-radius: 999px;
            border: 1px solid #4caf50;
            background: #1b3420;
            color: #e8ffe9;
            font-size: 0.95rem;
            cursor: pointer;
        }
        #overlay button:hover {
            background: #254f2c;
        }
        #hint {
            position: absolute;
            left: 50%;
            bottom: 1.2rem;
            transform: translateX(-50%);
            padding: 0.4rem 0.8rem;
            background: rgba(0, 0, 0, 0.55);
            border-radius: 999px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
<div id="game-container">
    <div id="overlay">
        <h1>Cube Labyrinth</h1>
        <p>WASD to move, mouse to look.</p>
        <p>Pull mouse down to look down, push up to look up.</p>
        <p>Press the button, then click to lock the mouse.</p>
        <button id="start-btn" type="button">Start</button>
    </div>
    <div id="hint">Press ESC to release the mouse</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.js"></script>
<script>
(function () {
    const MAP_DATA = [
        "XXXXXXXXXX",
        "Xs.....XXX",
        "XXXXXX.XXX",
        "XXXXXX.XXX",
        "XXX......X",
        "X.X......X",
        "X.X......X",
        "X.XX.XXX.X",
        "X........X",
        "XXXXXXXXXX"
    ];

    const PLAYER_HEIGHT = 1.7; // meters
    const EYE_HEIGHT = 1.6;    // camera height above ground
    const PLAYER_RADIUS = 0.25; // collision radius in meters
    const MOVE_SPEED = 3.0;    // meters per second
    const MOUSE_SENSITIVITY = 0.0023; // radians per pixel

    const container = document.getElementById('game-container');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('start-btn');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050509);

    const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.rotation.order = 'YXZ';

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    // Lighting
    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x222233, 0.8);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // Build labyrinth geometry
    const walls = [];
    const mapHeight = MAP_DATA.length;
    const mapWidth = MAP_DATA[0].length;

    const floorGeometry = new THREE.PlaneGeometry(mapWidth, mapHeight);
    const floorMaterial = new THREE.MeshStandardMaterial({
        color: 0x20252a,
        roughness: 0.9,
        metalness: 0.0
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.set((mapWidth - 1) / 2, 0, (mapHeight - 1) / 2);
    floor.receiveShadow = true;
    scene.add(floor);

    const wallGeometry = new THREE.BoxGeometry(1, 1, 1);
    const wallMaterial = new THREE.MeshStandardMaterial({
        color: 0x46637a,
        roughness: 0.6,
        metalness: 0.1
    });

    let startX = 1;
    let startZ = 1;

    for (let z = 0; z < mapHeight; z++) {
        const row = MAP_DATA[z];
        for (let x = 0; x < mapWidth; x++) {
            const cell = row[x];
            const worldX = x;
            const worldZ = z;

            if (cell === 'X') {
                const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                wall.position.set(worldX, 0.5, worldZ);
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
                walls.push({ x: worldX, z: worldZ, half: 0.5 });
            } else if (cell === 's') {
                startX = worldX;
                startZ = worldZ;
            }
        }
    }

    camera.position.set(startX, EYE_HEIGHT, startZ);

    // Player state
    let yaw = 0;
    let pitch = 0;
    const pitchLimit = Math.PI / 2 - 0.01;

    function applyCameraRotation() {
        camera.rotation.set(pitch, yaw, 0);
    }

    applyCameraRotation();

    // Pointer lock & controls
    const canvas = renderer.domElement;
    let isPointerLocked = false;

    function lockPointer() {
        if (canvas.requestPointerLock) {
            canvas.requestPointerLock();
        }
    }

    document.addEventListener('pointerlockchange', function () {
        isPointerLocked = (document.pointerLockElement === canvas);
        overlay.style.display = isPointerLocked ? 'none' : 'flex';
    });

    startBtn.addEventListener('click', function () {
        lockPointer();
    });

    canvas.addEventListener('click', function () {
        if (!isPointerLocked) {
            lockPointer();
        }
    });

    document.addEventListener('mousemove', function (event) {
        if (!isPointerLocked) return;
        const movementX = event.movementX || 0;
        const movementY = event.movementY || 0;

        // Horizontal: usual yaw
        yaw -= movementX * MOUSE_SENSITIVITY;

        // Vertical: pulling mouse down (movementY > 0) should look down,
        // so we increase pitch when movementY is positive.
        pitch += movementY * MOUSE_SENSITIVITY;
        if (pitch > pitchLimit) pitch = pitchLimit;
        if (pitch < -pitchLimit) pitch = -pitchLimit;

        applyCameraRotation();
    });

    // Keyboard input
    const keys = Object.create(null);

    function setKey(code, isDown) {
        if (code === 'KeyW' || code === 'KeyA' || code === 'KeyS' || code === 'KeyD') {
            keys[code] = isDown;
        }
    }

    document.addEventListener('keydown', function (event) {
        setKey(event.code, true);
    });

    document.addEventListener('keyup', function (event) {
        setKey(event.code, false);
    });

    // Collision detection against walls
    function collidesWithWalls(x, z) {
        for (let i = 0; i < walls.length; i++) {
            const w = walls[i];
            const dx = Math.abs(x - w.x);
            const dz = Math.abs(z - w.z);
            const minDistX = w.half + PLAYER_RADIUS;
            const minDistZ = w.half + PLAYER_RADIUS;
            if (dx < minDistX && dz < minDistZ) {
                return true;
            }
        }
        return false;
    }

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();

        if (isPointerLocked) {
            let forward = 0;
            let strafe = 0;

            if (keys['KeyW']) forward += 1;
            if (keys['KeyS']) forward -= 1;
            if (keys['KeyD']) strafe += 1;
            if (keys['KeyA']) strafe -= 1;

            if (forward !== 0 || strafe !== 0) {
                const len = Math.hypot(forward, strafe);
                if (len > 0) {
                    forward /= len;
                    strafe /= len;
                }

                const sinYaw = Math.sin(yaw);
                const cosYaw = Math.cos(yaw);

                const dirX = -sinYaw;
                const dirZ = -cosYaw;
                const strafeX = cosYaw;
                const strafeZ = -sinYaw;

                const moveStep = MOVE_SPEED * delta;
                const moveX = (dirX * forward + strafeX * strafe) * moveStep;
                const moveZ = (dirZ * forward + strafeZ * strafe) * moveStep;

                const currentX = camera.position.x;
                const currentZ = camera.position.z;

                const newX = currentX + moveX;
                const newZ = currentZ + moveZ;

                // Separate axis collision resolution
                if (!collidesWithWalls(newX, currentZ)) {
                    camera.position.x = newX;
                }
                if (!collidesWithWalls(camera.position.x, newZ)) {
                    camera.position.z = newZ;
                }

                camera.position.y = EYE_HEIGHT; // keep constant height
            }
        }

        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', function () {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
})();
</script>
</body>
</html>
