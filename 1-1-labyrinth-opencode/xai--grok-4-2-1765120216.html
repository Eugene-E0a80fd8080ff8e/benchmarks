&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Labyrinth Game&lt;/title&gt;
    &lt;style&gt;
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        const map = [
            &#39;XXXXXXXXXX&#39;,
            &#39;Xs.....XXX&#39;,
            &#39;XXXXXX.XXX&#39;,
            &#39;XXXXXX.XXX&#39;,
            &#39;XXX......X&#39;,
            &#39;X.X......X&#39;,
            &#39;X.X......X&#39;,
            &#39;X.XX.XXX.X&#39;,
            &#39;X........X&#39;,
            &#39;XXXXXXXXXX&#39;
        ];

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 1.7;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        const floorGeometry = new THREE.PlaneGeometry(10, 10);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x228b22 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
        const walls = [];
        let startX, startZ;

        for (let z = 0; z &lt; 10; z++) {
            for (let x = 0; x &lt; 10; x++) {
                const cell = map[z][x];
                if (cell === &#39;X&#39;) {
                    const wallGeometry = new THREE.BoxGeometry(1, 2, 1);
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(x, 1, z);
                    scene.add(wall);
                    walls.push(new THREE.Box3().setFromObject(wall));
                } else if (cell === &#39;s&#39;) {
                    startX = x;
                    startZ = z;
                }
            }
        }

        camera.position.set(startX + 0.5, 1.7, startZ + 0.5);

        const controls = new THREE.PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        document.addEventListener(&#39;click&#39;, () =&gt; {
            controls.lock();
        });

        const moveSpeed = 0.1;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const keys = {};

        document.addEventListener(&#39;keydown&#39;, (event) =&gt; { keys[event.key.toLowerCase()] = true; });
        document.addEventListener(&#39;keyup&#39;, (event) =&gt; { keys[event.key.toLowerCase()] = false; });

        function checkCollision(newPosition) {
            const playerBox = new THREE.Box3(new THREE.Vector3(newPosition.x - 0.2, 0, newPosition.z - 0.2), new THREE.Vector3(newPosition.x + 0.2, 2, newPosition.z + 0.2));
            for (const wall of walls) {
                if (playerBox.intersectsBox(wall)) return true;
            }
            return false;
        }

        function animate() {
            requestAnimationFrame(animate);

            velocity.x = 0;
            velocity.z = 0;

            direction.z = Number(keys[&#39;w&#39;]) - Number(keys[&#39;s&#39;]);
            direction.x = Number(keys[&#39;d&#39;]) - Number(keys[&#39;a&#39;]);
            direction.normalize();

            if (keys[&#39;w&#39;] || keys[&#39;s&#39;]) velocity.z = direction.z * moveSpeed;
            if (keys[&#39;a&#39;] || keys[&#39;d&#39;]) velocity.x = direction.x * moveSpeed;

            const delta = velocity.clone().applyQuaternion(camera.quaternion);

            const newPosition = camera.position.clone().add(delta);

            if (!checkCollision(newPosition)) {
                camera.position.add(delta);
            }

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener(&#39;resize&#39;, () =&gt; {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        controls.addEventListener(&#39;change&#39;, () =&gt; {
            const pitchQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), camera.rotation.x);
            pitchQuaternion.x *= -1;
            camera.setRotationFromQuaternion(pitchQuaternion.multiply(new THREE.Quaternion().setFromEuler(camera.rotation)));
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;