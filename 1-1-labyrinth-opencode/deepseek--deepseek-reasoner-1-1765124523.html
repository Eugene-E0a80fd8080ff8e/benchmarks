<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth Game</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            font-family: sans-serif;
            background: #000;
            color: #fff;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            pointer-events: none;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        <div id="ui">
            <h1>Labyrinth</h1>
            <p>Click to start, use WASD to move, mouse to look</p>
        </div>
        <div id="instructions">
            <p>Click to lock pointer. Escape to release.</p>
        </div>
    </div>

    <script>
        // Map definition
        const map = [
            'XXXXXXXXXX',
            'Xs.....XXX',
            'XXXXXX.XXX',
            'XXXXXX.XXX',
            'XXX......X',
            'X.X......X',
            'X.X......X',
            'X.XX.XXX.X',
            'X........X',
            'XXXXXXXXXX'
        ];

        const MAP_WIDTH = map[0].length;
        const MAP_HEIGHT = map.length;
        const CELL_SIZE = 1; // 1 meter
        const WALL_HEIGHT = 2; // wall height meters
        const PLAYER_HEIGHT = 1.7; // meters

        // Parse map to find walls and start position
        const walls = [];
        let startX = 0, startZ = 0;

        for (let z = 0; z < MAP_HEIGHT; z++) {
            const row = map[z];
            for (let x = 0; x < MAP_WIDTH; x++) {
                const cell = row[x];
                if (cell === 'X') {
                    walls.push({ x, z });
                } else if (cell === 's') {
                    startX = x + 0.5; // center of cell
                    startZ = z + 0.5;
                }
            }
        }

        // Three.js variables
        let scene, camera, renderer;
        let wallsGroup;
        let keys = {};
        let pointerLocked = false;
        let pitch = 0; // vertical rotation in radians
        let yaw = 0;   // horizontal rotation in radians
        const MOUSE_SENSITIVITY = 0.002;
        const MAX_PITCH = Math.PI / 2.5; // limit looking up/down
        const PLAYER_SPEED = 5; // meters per second

        // Player position
        const player = {
            x: startX,
            y: PLAYER_HEIGHT,
            z: startZ,
            velocity: { x: 0, y: 0, z: 0 }
        };

        // Initialize Three.js scene
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // sky blue

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(player.x, player.y, player.z);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(MAP_WIDTH * CELL_SIZE, MAP_HEIGHT * CELL_SIZE);
            const groundMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Walls
            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            wallsGroup = new THREE.Group();
            for (const wall of walls) {
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                wallMesh.position.set(wall.x * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 2, wall.z * CELL_SIZE + CELL_SIZE / 2);
                wallMesh.castShadow = true;
                wallMesh.receiveShadow = true;
                wallsGroup.add(wallMesh);
            }
            scene.add(wallsGroup);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onClick);

            // Start animation
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            keys[event.code] = true;
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function onClick() {
            const canvas = document.getElementById('canvas');
            if (!pointerLocked) {
                canvas.requestPointerLock();
            }
        }

        // Pointer lock change
        document.addEventListener('pointerlockchange', () => {
            pointerLocked = document.pointerLockElement === document.getElementById('canvas');
        });

        function onMouseMove(event) {
            if (!pointerLocked) return;
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            yaw -= movementX * MOUSE_SENSITIVITY;
            pitch += movementY * MOUSE_SENSITIVITY;
            pitch = Math.max(-MAX_PITCH, Math.min(MAX_PITCH, pitch));
        }

        function updatePlayer(delta) {
            // Movement direction based on camera orientation
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
            right.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

            const move = new THREE.Vector3(0, 0, 0);
            if (keys['KeyW']) move.add(forward);
            if (keys['KeyS']) move.sub(forward);
            if (keys['KeyA']) move.sub(right);
            if (keys['KeyD']) move.add(right);
            move.normalize().multiplyScalar(PLAYER_SPEED * delta);

            // Simple collision detection
            const newX = player.x + move.x;
            const newZ = player.z + move.z;

            // Check wall collisions
            let canMoveX = true;
            let canMoveZ = true;
            const playerRadius = 0.3;
            for (const wall of walls) {
                const wx = wall.x * CELL_SIZE + CELL_SIZE / 2;
                const wz = wall.z * CELL_SIZE + CELL_SIZE / 2;
                const wallHalf = CELL_SIZE / 2 + playerRadius;
                if (Math.abs(newX - wx) < wallHalf && Math.abs(player.z - wz) < wallHalf) {
                    canMoveX = false;
                }
                if (Math.abs(player.x - wx) < wallHalf && Math.abs(newZ - wz) < wallHalf) {
                    canMoveZ = false;
                }
            }

            if (canMoveX) player.x = newX;
            if (canMoveZ) player.z = newZ;

            // Update camera position and rotation
            camera.position.set(player.x, player.y, player.z);
            camera.rotation.set(yaw, pitch, 0, 'YXZ');
        }

        function animate(time) {
            requestAnimationFrame(animate);
            const delta = Math.min(0.1, (time - (animate.lastTime || time)) / 1000);
            animate.lastTime = time;

            updatePlayer(delta);
            renderer.render(scene, camera);
        }

        // Start the game
        window.onload = init;
    </script>
</body>
</html>