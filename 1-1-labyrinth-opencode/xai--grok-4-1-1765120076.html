&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Labyrinth Game&lt;/title&gt;
    &lt;style&gt;
        body { margin: 0; }
        canvas { display: block; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        const map = [
            &#39;XXXXXXXXXX&#39;,
            &#39;Xs.....XXX&#39;,
            &#39;XXXXXX.XXX&#39;,
            &#39;XXXXXX.XXX&#39;,
            &#39;XXX......X&#39;,
            &#39;X.X......X&#39;,
            &#39;X.X......X&#39;,
            &#39;X.XX.XXX.X&#39;,
            &#39;X........X&#39;,
            &#39;XXXXXXXXXX&#39;
        ];

        const mapArray = map.map(row =&gt; row.split(&#39;&#39;));

        let startX, startZ;
        for (let z = 0; z &lt; mapArray.length; z++) {
            for (let x = 0; x &lt; mapArray[z].length; x++) {
                if (mapArray[z][x] === &#39;s&#39;) {
                    startX = x;
                    startZ = z;
                    mapArray[z][x] = &#39;.&#39;;
                }
            }
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(startX + 0.5, 1.7, startZ + 0.5);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(10, 10);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(5, 0, 5);
        scene.add(floor);

        // Walls
        const wallGeometry = new THREE.BoxGeometry(1, 1, 1);
        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        for (let z = 0; z &lt; mapArray.length; z++) {
            for (let x = 0; x &lt; mapArray[z].length; x++) {
                if (mapArray[z][x] === &#39;X&#39;) {
                    const cube = new THREE.Mesh(wallGeometry, wallMaterial);
                    cube.position.set(x + 0.5, 0.5, z + 0.5);
                    scene.add(cube);
                }
            }
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff);
        scene.add(ambientLight);

        // Controls
        let isLocked = false;
        renderer.domElement.addEventListener(&#39;click&#39;, () =&gt; {
            renderer.domElement.requestPointerLock();
        });

        document.addEventListener(&#39;pointerlockchange&#39;, () =&gt; {
            isLocked = document.pointerLockElement === renderer.domElement;
        });

        let yaw = 0;
        let pitch = 0;
        document.addEventListener(&#39;mousemove&#39;, (event) =&gt; {
            if (!isLocked) return;
            yaw -= event.movementX * 0.002;
            pitch -= event.movementY * 0.002;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
            camera.rotation.order = &#39;YXZ&#39;;
            camera.rotation.set(pitch, yaw, 0);
        });

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        document.addEventListener(&#39;keydown&#39;, (event) =&gt; {
            switch (event.key.toLowerCase()) {
                case &#39;w&#39;: moveForward = true; break;
                case &#39;s&#39;: moveBackward = true; break;
                case &#39;a&#39;: moveLeft = true; break;
                case &#39;d&#39;: moveRight = true; break;
            }
        });

        document.addEventListener(&#39;keyup&#39;, (event) =&gt; {
            switch (event.key.toLowerCase()) {
                case &#39;w&#39;: moveForward = false; break;
                case &#39;s&#39;: moveBackward = false; break;
                case &#39;a&#39;: moveLeft = false; break;
                case &#39;d&#39;: moveRight = false; break;
            }
        });

        // Resize handler
        window.addEventListener(&#39;resize&#39;, () =&gt; {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const clock = new THREE.Clock();

        function isWalkable(x, z) {
            const cellX = Math.floor(x);
            const cellZ = Math.floor(z);
            if (cellX &lt; 0 || cellX &gt;= 10 || cellZ &lt; 0 || cellZ &gt;= 10) return false;
            return mapArray[cellZ][cellX] !== &#39;X&#39;;
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const speed = 5 * delta; // 5 m/s

            let directionZ = Number(moveForward) - Number(moveBackward);
            let directionX = Number(moveRight) - Number(moveLeft);

            if (directionZ !== 0 || directionX !== 0) {
                // Normalize direction
                const length = Math.sqrt(directionX * directionX + directionZ * directionZ);
                directionX /= length || 1;
                directionZ /= length || 1;

                // Get camera direction
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();

                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                right.y = 0;
                right.normalize();

                const velocity = new THREE.Vector3();
                velocity.add(forward.multiplyScalar(directionZ * speed));
                velocity.add(right.multiplyScalar(directionX * speed));

                // Move separately for collision
                let newX = camera.position.x + velocity.x;
                let newZ = camera.position.z + velocity.z;

                if (isWalkable(newX, camera.position.z)) {
                    camera.position.x = newX;
                }
                if (isWalkable(camera.position.x, newZ)) {
                    camera.position.z = newZ;
                }
            }

            renderer.render(scene, camera);
        }

        animate();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;