<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Labyrinth Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: #000;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10;
        }
        
        #info p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="info">
        <p><strong>Labyrinth Game</strong></p>
        <p>W/A/S/D - Move | Mouse - Look around</p>
        <p>Click to lock mouse pointer</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Map definition
        const mapString = `XXXXXXXXXX
Xs.....XXX
XXXXXX.XXX
XXXXXX.XXX
XXX......X
X.X......X
X.X......X
X.XX.XXX.X
X........X
XXXXXXXXXX`;

        // Parse map into 2D grid
        const mapLines = mapString.trim().split('\n');
        const grid = mapLines.map(line => line.split(''));
        
        const mapWidth = grid[0].length;
        const mapHeight = grid.length;
        
        // Find starting position
        let startX = 0, startZ = 0;
        for (let z = 0; z < mapHeight; z++) {
            for (let x = 0; x < mapWidth; x++) {
                if (grid[z][x] === 's') {
                    startX = x + 0.5;
                    startZ = z + 0.5;
                }
            }
        }

        // Three.js scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);
        scene.fog = new THREE.Fog(0x333333, 50, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(startX, 1.7, startZ); // Player height is 1.7m

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(mapWidth / 2, 10, mapHeight / 2);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -mapWidth;
        directionalLight.shadow.camera.right = mapWidth;
        directionalLight.shadow.camera.top = mapHeight;
        directionalLight.shadow.camera.bottom = -mapHeight;
        scene.add(directionalLight);

        // Create ground plane
        const groundGeometry = new THREE.PlaneGeometry(mapWidth, mapHeight);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = 0;
        ground.receiveShadow = true;
        scene.add(ground);

        // Create walls
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x8B7355 });
        const walls = [];
        
        for (let z = 0; z < mapHeight; z++) {
            for (let x = 0; x < mapWidth; x++) {
                if (grid[z][x] === 'X') {
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const mesh = new THREE.Mesh(geometry, wallMaterial);
                    mesh.position.set(x + 0.5, 0.5, z + 0.5);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    scene.add(mesh);
                    
                    walls.push({
                        x: x + 0.5,
                        z: z + 0.5,
                        size: 0.5 // Half-size for collision
                    });
                }
            }
        }

        // Player movement
        const keys = {};
        const player = {
            x: startX,
            z: startZ,
            velocity: new THREE.Vector3(),
            speed: 10,
            acceleration: 0.2,
            friction: 0.9
        };

        // Mouse control
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let pi_2 = Math.PI / 2;
        let mouseLocked = false;

        const onMouseMove = (event) => {
            if (!mouseLocked) return;

            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            euler.setFromQuaternion(camera.quaternion);
            euler.rotateY(-movementX * 0.002);
            euler.rotateX(-movementY * 0.002);
            euler.x = Math.max(-pi_2, Math.min(pi_2, euler.x));
            camera.quaternion.setFromEuler(euler);
        };

        const onMouseDown = () => {
            if (!mouseLocked) {
                document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
                document.body.requestPointerLock();
                mouseLocked = true;
            }
        };

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mousedown', onMouseDown);

        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === document.body;
        });
        document.addEventListener('mozpointerlockchange', () => {
            mouseLocked = document.mozPointerLockElement === document.body;
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Collision detection
        function checkCollision(x, z, radius = 0.3) {
            for (let wall of walls) {
                const dx = x - wall.x;
                const dz = z - wall.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance < radius + wall.size) {
                    return true;
                }
            }
            
            // Check map boundaries
            if (x < 0.3 || x > mapWidth - 0.3 || z < 0.3 || z > mapHeight - 0.3) {
                return true;
            }
            
            return false;
        }

        // Animation loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();
            const moveVector = new THREE.Vector3();

            // Get forward and right vectors from camera
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
            right.normalize();

            // Process input
            if (keys['w']) moveVector.add(forward);
            if (keys['s']) moveVector.sub(forward);
            if (keys['d']) moveVector.add(right);
            if (keys['a']) moveVector.sub(right);

            // Apply acceleration and friction
            if (moveVector.length() > 0) {
                moveVector.normalize();
                player.velocity.add(moveVector.multiplyScalar(player.acceleration));
            }
            
            player.velocity.multiplyScalar(player.friction);
            
            // Calculate new position
            let newX = player.x + player.velocity.x * deltaTime * player.speed;
            let newZ = player.z + player.velocity.z * deltaTime * player.speed;

            // Check collision
            if (!checkCollision(newX, newZ)) {
                player.x = newX;
                player.z = newZ;
            }

            // Update camera position
            camera.position.x = player.x;
            camera.position.z = player.z;
            camera.position.y = 1.7;

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
