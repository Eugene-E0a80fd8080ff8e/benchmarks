<!DOCTYPE html>
<html>
<head>
    <title>Labyrinth</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.7);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 2em;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="overlay">Click to start</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Labyrinth map
        const mapString = `
XXXXXXXXXX
Xs.....XXX
XXXXXX.XXX
XXXXXX.XXX
XXX......X
X.X......X
X.X......X
X.XX.XXX.X
X........X
XXXXXXXXXX`;

        // Parse map
        const rows = mapString.trim().split('\n');
        const gridSize = rows.length; // 10
        const walls = Array.from({ length: gridSize }, () => new Array(gridSize).fill(false));
        let startX = 0, startZ = 0;

        for (let z = 0; z < gridSize; z++) {
            const row = rows[z].trim();
            for (let x = 0; x < gridSize; x++) {
                const ch = row[x];
                if (ch === 'X') {
                    walls[z][x] = true;
                } else if (ch === 's') {
                    startX = x + 0.5;
                    startZ = z + 0.5;
                }
            }
        }

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(startX, 1.7, startZ);
        camera.lookAt(startX, 1.7, startZ - 1); // look north

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(gridSize, gridSize);
        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x66bb66 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(gridSize / 2, 0, gridSize / 2);
        scene.add(floor);

        // Walls
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
        for (let z = 0; z < gridSize; z++) {
            for (let x = 0; x < gridSize; x++) {
                if (walls[z][x]) {
                    const wall = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), wallMaterial);
                    wall.position.set(x + 0.5, 0.5, z + 0.5);
                    scene.add(wall);
                }
            }
        }

        // Collision detection
        function collides(x, z) {
            if (x < 0 || x >= gridSize || z < 0 || z >= gridSize) return true;
            const ix = Math.floor(x);
            const iz = Math.floor(z);
            return walls[iz][ix];
        }

        // Movement variables
        const moveSpeed = 5;
        const keys = { w: false, a: false, s: false, d: false };
        document.addEventListener('keydown', (e) => {
            if (e.key in keys) keys[e.key] = true;
        });
        document.addEventListener('keyup', (e) => {
            if (e.key in keys) keys[e.key] = false;
        });

        // Pointer lock controls
        const overlay = document.getElementById('overlay');
        const canvas = renderer.domElement;

        overlay.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                overlay.style.display = 'none';
            } else {
                overlay.style.display = 'flex';
            }
        });

        let pitch = 0, yaw = 0;
        const sensitivity = 0.002;
        document.addEventListener('mousemove', (e) => {
            if (document.pointerLockElement === canvas) {
                yaw -= e.movementX * sensitivity;
                pitch -= e.movementY * sensitivity;
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
                camera.rotation.set(pitch, yaw, 0, 'YXZ');
            }
        });

        // Animation loop
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (document.pointerLockElement === canvas) {
                // Compute movement direction
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                right.y = 0;
                right.normalize();

                let moveX = 0, moveZ = 0;
                if (keys.w) { moveX += forward.x; moveZ += forward.z; }
                if (keys.s) { moveX -= forward.x; moveZ -= forward.z; }
                if (keys.a) { moveX -= right.x; moveZ -= right.z; }
                if (keys.d) { moveX += right.x; moveZ += right.z; }

                if (moveX !== 0 || moveZ !== 0) {
                    const len = Math.sqrt(moveX * moveX + moveZ * moveZ);
                    moveX /= len;
                    moveZ /= len;
                    const speed = moveSpeed * delta;
                    const newX = camera.position.x + moveX * speed;
                    const newZ = camera.position.z + moveZ * speed;

                    // Collision checks per axis
                    if (!collides(newX, camera.position.z)) {
                        camera.position.x = newX;
                    }
                    if (!collides(camera.position.x, newZ)) {
                        camera.position.z = newZ;
                    }
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
