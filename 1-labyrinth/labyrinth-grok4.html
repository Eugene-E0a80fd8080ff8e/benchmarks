<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Labyrinth Game</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <script>
        // Map definition
        const map = [
            'XXXXXXXXXX',
            'Xs.....XXX',
            'XXXXXX.XXX',
            'XXXXXX.XXX',
            'XXX......X',
            'X.X......X',
            'X.X......X',
            'X.XX.XXX.X',
            'X........X',
            'XXXXXXXXXX'
        ];

        // Find starting position
        let startX, startZ;
        const grid = map.map((row, z) => row.split('').map((cell, x) => {
            if (cell === 's') {
                startX = x;
                startZ = z;
                return '.';
            }
            return cell;
        }));

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(startX + 0.5, 1.7, startZ + 0.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 10, 0);
        scene.add(directionalLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(10, 10);
        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = Math.PI / 2;
        scene.add(floor);

        // Walls
        const wallGeometry = new THREE.BoxGeometry(1, 2, 1);
        const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
        for (let z = 0; z < grid.length; z++) {
            for (let x = 0; x < grid[z].length; x++) {
                if (grid[z][x] === 'X') {
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(x + 0.5, 1, z + 0.5);
                    scene.add(wall);
                }
            }
        }

        // Controls
        const controls = new THREE.PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        document.body.addEventListener('click', () => {
            controls.lock();
        });

        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        // Collision detection
        function canMoveTo(newX, newZ) {
            const gridX = Math.floor(newX);
            const gridZ = Math.floor(newZ);
            if (gridX < 0 || gridX >= 10 || gridZ < 0 || gridZ >= 10) return false;
            return grid[gridZ][gridX] === '.';
        }

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const speed = 3; // m/s

            velocity.x = 0;
            velocity.z = 0;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z = direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x = direction.x * speed * delta;

            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3();
            right.crossVectors(forward, camera.up).normalize();

            const moveZ = forward.multiplyScalar(velocity.z);
            const moveX = right.multiplyScalar(velocity.x);

            const newPosition = camera.position.clone().add(moveZ).add(moveX);

            // Check collision with small radius
            const radius = 0.2;
            const checkPositions = [
                newPosition.clone(),
                newPosition.clone().add(new THREE.Vector3(radius, 0, 0)),
                newPosition.clone().add(new THREE.Vector3(-radius, 0, 0)),
                newPosition.clone().add(new THREE.Vector3(0, 0, radius)),
                newPosition.clone().add(new THREE.Vector3(0, 0, -radius))
            ];

            let canMove = true;
            for (const pos of checkPositions) {
                if (!canMoveTo(pos.x, pos.z)) {
                    canMove = false;
                    break;
                }
            }

            if (canMove) {
                camera.position.copy(newPosition);
            } else {
                // Partial movement: try moving only in Z or only in X
                const newPosZ = camera.position.clone().add(moveZ);
                canMove = true;
                for (const pos of checkPositions.map(p => p.clone().sub(moveX).add(new THREE.Vector3(0,0,0)))) {
                    if (!canMoveTo(pos.x, pos.z)) {
                        canMove = false;
                        break;
                    }
                }
                if (canMove) {
                    camera.position.copy(newPosZ);
                } else {
                    const newPosX = camera.position.clone().add(moveX);
                    canMove = true;
                    for (const pos of checkPositions.map(p => p.clone().sub(moveZ).add(new THREE.Vector3(0,0,0)))) {
                        if (!canMoveTo(pos.x, pos.z)) {
                            canMove = false;
                            break;
                        }
                    }
                    if (canMove) {
                        camera.position.copy(newPosX);
                    }
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
